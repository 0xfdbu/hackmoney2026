// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "forge-std/Script.sol";
import "forge-std/console.sol";

contract DebugZKVerification is Script {
    // Verifier address
    address constant VERIFIER = 0x0fd9c5aF93935fD91d355Ad7cbbf36712e368f71;
    
    // Test proof data (from a working browser proof)
    // These would be filled with actual values from your frontend
    struct ProofData {
        uint256[2] a;
        uint256[2][2] b;
        uint256[2] c;
        uint256[7] publicSignals;
    }
    
    function run() external {
        console.log("=== ZK Verification Debug ===");
        console.log("Verifier:", VERIFIER);
        
        // Test 1: Check verifier exists
        uint256 verifierCodeSize = VERIFIER.code.length;
        console.log("Verifier code size:", verifierCodeSize);
        if (verifierCodeSize == 0) {
            console.log("ERROR: Verifier has no code!");
            return;
        }
        
        // Test 2: Try to call verifier with dummy data
        // This should fail proof validation but show us the revert reason
        console.log("\n=== Test 2: Call verifier directly ===");
        
        uint256[2] memory a = [uint256(1), uint256(2)];
        uint256[2][2] memory b = [[uint256(3), uint256(4)], [uint256(5), uint256(6)]];
        uint256[2] memory c = [uint256(7), uint256(8)];
        uint256[7] memory signals = [uint256(1), uint256(2), uint256(3), uint256(4), uint256(5), uint256(6), uint256(7)];
        
        (bool success, bytes memory returnData) = VERIFIER.staticcall(
            abi.encodeWithSignature(
                "verifyProof(uint256[2],uint256[2][2],uint256[2],uint256[7])",
                a, b, c, signals
            )
        );
        
        console.log("Call success:", success);
        console.log("Return data length:", returnData.length);
        if (returnData.length > 0) {
            bool result = abi.decode(returnData, (bool));
            console.log("Verifier returned:", result);
        }
        
        // Test 3: Try with a real proof from file
        console.log("\n=== Test 3: Load and verify real proof ===");
        _testRealProof();
    }
    
    function _testRealProof() internal {
        // Read proof from file (generated by frontend)
        // This file should be created by your frontend after generating a proof
        string memory proofPath = "test/proof.json";
        
        try vm.readFile(proofPath) returns (string memory json) {
            console.log("Loaded proof from file");
            
            // Parse proof components
            bytes memory aBytes = vm.parseJson(json, ".pi_a");
            bytes memory bBytes = vm.parseJson(json, ".pi_b");
            bytes memory cBytes = vm.parseJson(json, ".pi_c");
            bytes memory pubSignalsBytes = vm.parseJson(json, ".publicSignals");
            
            console.log("pi_a length:", aBytes.length);
            console.log("pi_b length:", bBytes.length);
            console.log("pi_c length:", cBytes.length);
            console.log("publicSignals length:", pubSignalsBytes.length);
            
            // Log raw values
            console.log("\nRaw proof values:");
            _logProofValues(json);
            
        } catch {
            console.log("No proof file found at:", proofPath);
            console.log("Generate a proof in the browser and save it to contracts/test/proof.json");
        }
    }
    
    function _logProofValues(string memory json) internal pure {
        // Log first few values to check format
        console.log("Proof JSON preview:");
        // Can't easily substring in Solidity, but we logged the parse attempt
    }
}
